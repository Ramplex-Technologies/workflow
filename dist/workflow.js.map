{"version":3,"sources":["../src/workflow.ts","../src/_context.ts","../src/_dependency-map.ts","../src/_node.ts","../src/error.ts"],"sourcesContent":["/* --------------------------------------------------------------------------\n\n  MIT License\n\n  Copyright (c) 2025 Rami Pellumbi\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"), to deal\n  in the Software without restriction, including without limitation the rights\n  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n  copies of the Software, and to permit persons to whom the Software is\n  furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included in all\n  copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n-----------------------------------------------------------------------------*/\n\nimport { Context } from \"./_context\";\nimport { DependencyMap } from \"./_dependency-map\";\nimport { Node, type NodeCompletionEvent, type NodeOptions } from \"./_node\";\nimport { NodeError } from \"./error\";\n\ntype DeepReadonly<T> = {\n    readonly [P in keyof T]: T[P] extends object ? DeepReadonly<T[P]> : T[P];\n};\n\n/**\n * Represents a workflow which nodes can be added to\n * When built, the graph will be sorted topologically and returned as a `WorkflowRunner` instance.\n *\n * @template TInitialNodeContext - Type of the context in the `initial` key that each node will receive\n * @template TNodeContext - Type of the context each node will receive\n * @template TAllDependencyIds - The node IDs that can be used as dependencies for new nodes\n */\nexport class Workflow<\n    TInitialNodeContext = undefined,\n    TNodeContext extends Record<string, unknown> = {\n        readonly initial: DeepReadonly<TInitialNodeContext>;\n    },\n    TAllDependencyIds extends string = never,\n> {\n    readonly #contextValueOrFactory:\n        | TInitialNodeContext\n        | (() => DeepReadonly<TInitialNodeContext> | Promise<DeepReadonly<TInitialNodeContext>>)\n        | undefined = undefined;\n    readonly #nodes = new Map<\n        string,\n        Node<TNodeContext & { readonly initial: DeepReadonly<TInitialNodeContext> }, unknown, string>\n    >();\n    readonly #nodeDependencies = new DependencyMap();\n    readonly #topologicalOrder: string[] = [];\n\n    constructor(\n        options?:\n            | {\n                  contextValue?: TInitialNodeContext;\n              }\n            | {\n                  contextFactory: () => TInitialNodeContext | Promise<TInitialNodeContext>;\n              },\n    ) {\n        // Early return if no options provided\n        if (!options) {\n            return;\n        }\n\n        // Validate only one of the context options\n        if (\"contextValue\" in options && \"contextFactory\" in options) {\n            throw new Error(\"Cannot specify both contextValue and contextFactory\");\n        }\n\n        if (\"contextValue\" in options) {\n            if (options.contextValue !== undefined) {\n                if (typeof options.contextValue === \"function\") {\n                    throw new Error(\"Context value must not be a function\");\n                }\n                this.#contextValueOrFactory = options.contextValue;\n            }\n        } else if (\"contextFactory\" in options) {\n            if (typeof options.contextFactory !== \"function\") {\n                throw new Error(\"Context factory must be a function that returns a value or Promise\");\n            }\n            this.#contextValueOrFactory = options.contextFactory;\n        }\n    }\n\n    /**\n     * Adds a new node to the workflow.\n     *\n     * @template TNodeId The ID of the node, which must be unique.\n     * @template TNodeDependencyIds The IDs of the node's dependencies.\n     * @template TNodeReturn The return type of the node.\n     * @param options The configuration options for the node:\n     * @param options.id A unique identifier for the node.\n     * @param options.execute A function that performs the node's operation. It receives an object with the `ctx` (context) property.\n     * @param options.dependencies An optional array of node IDs that this node depends on. If not provided, the node will be executed immediately on start.\n     * @param options.retryPolicy An optional retry policy for the node, specifying maxRetries and retryDelayMs. Defaults to no retries.\n     * @param options.errorHandler An optional function to handle errors that occur during node execution. Defaults to `console.error`.\n     *\n     * @returns The instance of `Workflow` with the new node added for chaining.\n     *\n     * @throws {Error} If a node with the same ID already exists.\n     * @throws {Error} If a specified dependency node has not been added to the workflow yet.\n     */\n    addNode<TNodeId extends string, TNodeReturn, TNodeDependencyIds extends TAllDependencyIds = never>(\n        options: NodeOptions<\n            TNodeId,\n            TNodeContext & { readonly initial: DeepReadonly<TInitialNodeContext> },\n            TNodeReturn,\n            TNodeDependencyIds\n        >,\n    ): Workflow<\n        TInitialNodeContext,\n        TNodeContext & { readonly [K in TNodeId]?: TNodeReturn },\n        TAllDependencyIds | TNodeId\n    > {\n        const nodeId = options.id;\n        if (options.id === \"initial\") {\n            throw new Error(`Node with id '${options.id}' cannot be created. 'initial' is a reserved keyword.`);\n        }\n        if (this.#nodes.has(nodeId)) {\n            throw new Error(`Node with id ${nodeId} already exists`);\n        }\n\n        const node = new Node(options);\n        for (const depId of options.dependencies ?? []) {\n            if (typeof depId !== \"string\") {\n                throw new Error(\"Dependency ID must be a string\");\n            }\n            if ((depId as string) === nodeId) {\n                throw new Error(`Node ${nodeId} cannot depend on itself`);\n            }\n            const dependentNode = this.#nodes.get(depId);\n            if (!dependentNode) {\n                throw new Error(`Dependency ${depId} not found for node ${nodeId}`);\n            }\n            this.#nodeDependencies.add(nodeId, depId);\n        }\n\n        // biome-ignore lint/suspicious/noExplicitAny: the typing here is super annoying\n        this.#nodes.set(nodeId, node as any);\n        // biome-ignore lint/suspicious/noExplicitAny: do not want to track the type in two places\n        return this as any;\n    }\n\n    /**\n     * Builds and returns a WorkflowRunner instance.\n     * This method finalizes the workflow and prepares it for execution by topologically sorting the nodes.\n     * @param options The configuration options for the build\n     * @param options.onNodesCompleted A (sync or async) function to invoke when all nodes have completed\n     * @returns A new `WorkflowRunner` instance ready to execute the workflow.\n     *\n     * @throws {Error} If no nodes have been added to the workflow.\n     */\n    build({\n        onNodesCompleted,\n    }: {\n        onNodesCompleted?: (ctx: DeepReadonly<TNodeContext>, errors: NodeError[] | null) => void | Promise<void>;\n    } = {}): WorkflowRunner<\n        TInitialNodeContext,\n        TNodeContext & { readonly initial: DeepReadonly<TInitialNodeContext> }\n    > {\n        if (!this.size) {\n            throw new Error(\"Unable to build WorkflowRunner. No nodes added to the workflow\");\n        }\n        if (onNodesCompleted && typeof onNodesCompleted !== \"function\") {\n            throw new Error(\"onNodesCompleted must be a function (sync or async).\");\n        }\n        this.#topologicalSort();\n        return new WorkflowRunner<\n            TInitialNodeContext,\n            TNodeContext & { readonly initial: DeepReadonly<TInitialNodeContext> }\n        >(this.#contextValueOrFactory, this.#topologicalOrder, this.#nodes, this.#nodeDependencies, onNodesCompleted);\n    }\n\n    /**\n     * Returns the number of nodes in the workflow.\n     */\n    get size(): number {\n        return this.#nodes.size;\n    }\n\n    /**\n     * Topologically sorts the nodes in the workflow, placing the sorted order in the `_topologicalOrder` array.\n     */\n    #topologicalSort() {\n        const visited = new Set<string>();\n        const temp = new Set<string>();\n\n        const visit = (nodeId: string) => {\n            if (temp.has(nodeId)) {\n                throw new Error(`Circular dependency detected involving node ${nodeId}`);\n            }\n            if (!visited.has(nodeId)) {\n                temp.add(nodeId);\n                for (const depId of this.#nodeDependencies.get(nodeId)) {\n                    visit(depId);\n                }\n                temp.delete(nodeId);\n                visited.add(nodeId);\n                this.#topologicalOrder.push(nodeId);\n            }\n        };\n\n        for (const nodeId of this.#nodes.keys()) {\n            if (!visited.has(nodeId)) {\n                visit(nodeId);\n            }\n        }\n        visited.clear();\n        temp.clear();\n    }\n}\n\n/**\n * Represents a workflow runner that executes nodes in a topologically sorted order.\n * It assumes the passed nodes are already topologically sorted.\n *\n * @template TNodeContext - Type of the context each node will receive\n */\nexport class WorkflowRunner<TInitialNodeContext, TNodeContext extends Record<string, unknown> & { initial: unknown }> {\n    readonly #context = new Context<TInitialNodeContext, TNodeContext>();\n    readonly #contextValueOrFactory:\n        | undefined\n        | TInitialNodeContext\n        | (() => DeepReadonly<TInitialNodeContext> | Promise<DeepReadonly<TInitialNodeContext>>);\n    readonly #topologicalOrder: string[];\n    readonly #nodes: Map<string, Node<TNodeContext, unknown, string>>;\n    readonly #nodeDependencies: DependencyMap;\n    readonly #onNodesCompleted?: (ctx: TNodeContext, errors: NodeError[] | null) => void | Promise<void>;\n    readonly #errors: NodeError[] = [];\n\n    constructor(\n        contextValueOrFactory:\n            | undefined\n            | TInitialNodeContext\n            | (() => DeepReadonly<TInitialNodeContext> | Promise<DeepReadonly<TInitialNodeContext>>),\n        topologicalOrder: string[],\n        nodes: Map<string, Node<TNodeContext, unknown, string>>,\n        nodeDependencies: DependencyMap,\n        onNodesCompleted?: (ctx: TNodeContext, errors: NodeError[] | null) => void | Promise<void>,\n    ) {\n        this.#contextValueOrFactory = contextValueOrFactory;\n        this.#topologicalOrder = topologicalOrder;\n        this.#nodes = nodes;\n        this.#nodeDependencies = nodeDependencies;\n        this.#onNodesCompleted = onNodesCompleted;\n    }\n\n    async #run(): Promise<TNodeContext> {\n        if (this.#topologicalOrder.length === 0) {\n            throw new Error(\"No nodes to run. Did you forget to call topologicalSort?\");\n        }\n        let value: TInitialNodeContext | undefined;\n        if (this.#contextValueOrFactory) {\n            value =\n                typeof this.#contextValueOrFactory === \"function\"\n                    ? await (this.#contextValueOrFactory as () => TInitialNodeContext | Promise<TInitialNodeContext>)()\n                    : this.#contextValueOrFactory;\n            this.#context.reset(value);\n        }\n\n        const completed = new Set<string>();\n        const running = new Map<string, Promise<void>>();\n        const readyNodes = new Set<string>(\n            this.#topologicalOrder.filter((nodeId) => {\n                const node = this.#nodes.get(nodeId);\n                if (!node) {\n                    throw new Error(`Node ${nodeId} not found`);\n                }\n                return node.isEnabled && this.#nodeDependencies.get(nodeId).length === 0;\n            }),\n        );\n\n        const runNode = async (nodeId: string) => {\n            const node = this.#nodes.get(nodeId);\n            if (!node) {\n                throw new Error(`Node ${nodeId} not found`);\n            }\n\n            const startTime = Date.now();\n            try {\n                const result = await node.run(this.#context.value);\n                await this.#context.update({ [nodeId]: result });\n                completed.add(nodeId);\n\n                // Call node-specific handler if it exists\n                if (node.onCompleted) {\n                    try {\n                        const completionEvent: NodeCompletionEvent<TNodeContext> = {\n                            nodeId,\n                            status: \"completed\",\n                            result,\n                            context: this.#context.value,\n                            timestamp: new Date(),\n                            duration: Date.now() - startTime,\n                        };\n                        await node.onCompleted(completionEvent);\n                    } catch (err) {\n                        console.error(`Error in node completion handler for ${nodeId}:`, err);\n                    }\n                }\n            } catch (err) {\n                if (err instanceof Error) {\n                    this.#errors.push(new NodeError(nodeId, err));\n                }\n                // completed in the sense that we won't try to run it again\n                completed.add(nodeId);\n\n                // Call node-specific handler if it exists\n                if (node.onCompleted) {\n                    try {\n                        // Emit node failure event\n                        const failureEvent: NodeCompletionEvent<TNodeContext> = {\n                            nodeId,\n                            status: \"failed\",\n                            error: err instanceof Error ? new NodeError(nodeId, err) : undefined,\n                            context: this.#context.value,\n                            timestamp: new Date(),\n                            duration: Date.now() - startTime,\n                        };\n                        await node.onCompleted(failureEvent);\n                    } catch (err) {\n                        console.error(`Error in node completion handler for ${nodeId}:`, err);\n                    }\n                }\n            } finally {\n                running.delete(nodeId);\n\n                // Check if any dependent nodes are now ready to run\n                for (const [id, n] of this.#nodes) {\n                    if (!completed.has(id) && !running.has(id)) {\n                        const canRun =\n                            n.isEnabled &&\n                            this.#nodeDependencies.get(n.id).every((depId) => {\n                                const depNode = this.#nodes.get(depId);\n                                return (\n                                    depNode &&\n                                    completed.has(depId) &&\n                                    depNode.status === \"completed\" &&\n                                    depNode.isEnabled\n                                );\n                            });\n                        if (canRun) {\n                            readyNodes.add(id);\n                        }\n                    }\n                }\n            }\n        };\n\n        while (completed.size < this.#nodes.size) {\n            // Start all ready nodes\n            for (const nodeId of readyNodes) {\n                readyNodes.delete(nodeId);\n                const promise = runNode(nodeId);\n                running.set(nodeId, promise);\n            }\n\n            // Wait for at least one node to complete\n            if (running.size > 0) {\n                await Promise.race(running.values());\n            } else {\n                // no nodes are running and we have not completed all nodes\n                // happens when nodes could not run due to failed dependencies\n                // or when there is a set of nodes that can not be run due to\n                // a disabled node\n                break;\n            }\n        }\n\n        if (this.#onNodesCompleted) {\n            await this.#onNodesCompleted(this.#context.value, this.#errors.length > 0 ? this.#errors : null);\n        }\n\n        return this.#context.value;\n    }\n\n    /**\n     * Runs the nodes in the workflow in topological order.\n     * Nodes are run concurrently when possible.\n     * In the event a node fails, other independent nodes will continue to run.\n     *\n     * @returns A promise that resolves to the completed context object when all nodes have completed.\n     */\n    async trigger(): Promise<TNodeContext> {\n        try {\n            return await this.#run();\n        } finally {\n            this.#context.reset(undefined);\n            this.#errors.length = 0;\n        }\n    }\n\n    printWorkflow(): string {\n        if (this.#nodes.size === 0) {\n            return \"Empty workflow\";\n        }\n\n        const output: string[] = [\"```mermaid\", \"graph TD\"];\n        const edges = new Set<string>();\n\n        // Helper to sanitize node IDs for Mermaid\n        const sanitizeId = (id: string): string => {\n            // Replace special characters with underscores\n            return id.replace(/[^a-zA-Z0-9_]/g, \"_\");\n        };\n\n        // Helper to get node label\n        const getNodeLabel = (nodeId: string): string => {\n            const node = this.#nodes.get(nodeId);\n            if (!node) {\n                return nodeId;\n            }\n            return node.isEnabled ? nodeId : `${nodeId} (Disabled)`;\n        };\n\n        // Collect all edges\n        for (const [nodeId, node] of this.#nodes) {\n            const sanitizedNodeId = sanitizeId(nodeId);\n            const nodeLabel = getNodeLabel(nodeId);\n\n            // Add node definition\n            output.push(`    ${sanitizedNodeId}[\"${nodeLabel}\"]`);\n\n            // Style disabled nodes\n            if (!node.isEnabled) {\n                output.push(`    style ${sanitizedNodeId} fill:#ccc,stroke:#999,color:#666`);\n            }\n\n            const dependencies = this.#nodeDependencies.get(nodeId);\n            if (dependencies.length === 0) {\n                // Root node - no incoming edges\n                continue;\n            }\n\n            // Add edges from dependencies to this node\n            for (const depId of dependencies) {\n                const sanitizedDepId = sanitizeId(depId);\n                const edge = `    ${sanitizedDepId} --> ${sanitizedNodeId}`;\n                edges.add(edge);\n            }\n        }\n\n        // Add all edges\n        for (const edge of edges) {\n            output.push(edge);\n        }\n\n        output.push(\"```\");\n        return output.join(\"\\n\");\n    }\n}\n","/* --------------------------------------------------------------------------\n\n  MIT License\n\n  Copyright (c) 2025 Rami Pellumbi\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"), to deal\n  in the Software without restriction, including without limitation the rights\n  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n  copies of the Software, and to permit persons to whom the Software is\n  furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included in all\n  copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n-----------------------------------------------------------------------------*/\n\n/**\n * Used to allow for the sharing of state between tasks.\n */\nexport class Context<TInitial, TContext> {\n    #object!: { initial: TInitial | undefined } & TContext;\n    #updateQueue: Promise<void>;\n\n    constructor(initialValue?: TInitial) {\n        this.reset(initialValue);\n        this.#updateQueue = Promise.resolve();\n    }\n\n    /**\n     * Gets the current state of the managed object.\n     */\n    get value(): { initial: TInitial | undefined } & TContext {\n        return this.#object;\n    }\n\n    /**\n     * Resets the context to its initial state or a new initial object.\n     */\n    reset(initialValue: TInitial | undefined): void {\n        if (initialValue !== undefined && initialValue !== null) {\n            this.#object = deepFreeze({ initial: initialValue }) as {\n                initial: TInitial;\n            } & TContext;\n        } else {\n            this.#object = deepFreeze({ initial: undefined }) as {\n                initial: TInitial | undefined;\n            } & TContext;\n        }\n    }\n\n    /**\n     * Asynchronously updates the context with new values. Ensures that updates are applied in the order they are called.\n     */\n    update<NewValue extends object>(updateValue: NewValue): Promise<void> {\n        this.#updateQueue = this.#updateQueue.then(() => {\n            // overrides won't happen with how this is used since\n            // the initial context is under the key \"initial\"\n            // and all task results are under the unique id of that task\n            this.#object = deepFreeze({ ...this.#object, ...updateValue });\n            return Promise.resolve();\n        });\n        return this.#updateQueue;\n    }\n}\n\n// prevent runtime modifications to the context\nfunction deepFreeze<T extends object>(obj: T): Readonly<T> {\n    const propNames = Reflect.ownKeys(obj) as (keyof T)[];\n\n    for (const name of propNames) {\n        const value = obj[name];\n        if (value && typeof value === \"object\" && !Object.isFrozen(value)) {\n            deepFreeze(value);\n        }\n    }\n\n    return Object.freeze(obj);\n}\n","/* --------------------------------------------------------------------------\n  MIT License\n\n  Copyright (c) 2025 Rami Pellumbi\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"), to deal\n  in the Software without restriction, including without limitation the rights\n  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n  copies of the Software, and to permit persons to whom the Software is\n  furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included in all\n  copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n-----------------------------------------------------------------------------*/\n\n/**\n * Used to track which other tasks must execute before a task\n */\nexport class DependencyMap {\n    readonly #dependencies: Record<string, string[]> = Object.create(null);\n\n    add(key: string, value: string): void {\n        if (!this.#dependencies[key]) {\n            this.#dependencies[key] = [];\n        }\n        this.#dependencies[key].push(value);\n    }\n\n    get(key: string): readonly string[] {\n        return Object.freeze(this.#dependencies[key]?.slice() ?? []);\n    }\n}\n","/* --------------------------------------------------------------------------\n\n  MIT License\n\n  Copyright (c) 2025 Rami Pellumbi\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"), to deal\n  in the Software without restriction, including without limitation the rights\n  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n  copies of the Software, and to permit persons to whom the Software is\n  furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included in all\n  copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n-----------------------------------------------------------------------------*/\n\n// Creates a context type with required dependencies and optional other keys\ntype ContextWithDependencies<TContext extends Record<string, unknown>, TDependencies extends string> = Required<\n    Pick<TContext, TDependencies | \"initial\">\n> &\n    Partial<Omit<TContext, TDependencies | \"initial\">>;\n\nimport { setTimeout } from \"node:timers/promises\";\n\nimport type { NodeError } from \"./error\";\n\n/**\n * Event emitted when a node completes (successfully or with error)\n */\nexport interface NodeCompletionEvent<TNodeContext = unknown> {\n    nodeId: string;\n    status: \"completed\" | \"failed\" | \"skipped\";\n    result?: unknown;\n    error?: NodeError;\n    context: TNodeContext;\n    timestamp: Date;\n    duration?: number;\n    metadata?: Record<string, unknown>;\n}\n\n/**\n * Represents the options for a node.\n *\n * @template TNodeId - string literal type representing the node ID\n * @template TNodeContext - Type of node context passed into the node execution function\n * @template TNodeReturn - Type of node return value\n * @template TPossibleNodeDependencyId - string literal type representing the possible dependencies of this node\n * @template TInput - Type of the input object passed into the node execution function and error handler\n *\n */\nexport type NodeOptions<\n    TNodeId extends string,\n    TNodeContext extends Record<string, unknown> & { initial: unknown },\n    TNodeReturn,\n    TPossibleNodeDependencyId extends string = never,\n    TInput = [TPossibleNodeDependencyId] extends [never]\n        ? TNodeContext\n        : ContextWithDependencies<TNodeContext, TPossibleNodeDependencyId>,\n> = {\n    /**\n     * The unique ID of the node.\n     */\n    id: TNodeId;\n    /**\n     * The dependencies of the node.\n     */\n    dependencies?: readonly TPossibleNodeDependencyId[];\n    enabled?: boolean;\n    /**\n     * The retry policy for the node.\n     *\n     * @default { maxRetries: 0, retryDelayMs: 0 }\n     */\n    retryPolicy?: RetryPolicy;\n    /**\n     * The function that executes the node.\n     * This function receives the node context as input. It can be synchronous or asynchronous.\n     *\n     * @param ctx - The node context\n     * @returns The return value of the node\n     * @throws An error if the node execution fails after all retry attempts\n     */\n    execute: (ctx: TInput) => Promise<TNodeReturn> | TNodeReturn;\n    /**\n     * An optional error handler for the node.\n     * This function receives an error and the context as input. It can be synchronous or asynchronous.\n     * When an error handler is provided, it will be invoked when the node execution fails after all retry attempts.\n     * The error will still be thrown after the error handler has been executed.\n     *\n     * @param err - The error that occurred during node execution\n     * @param ctx - The node context\n     * @returns A promise that resolves when the error has been handled\n     * @default console.error\n     */\n    errorHandler?: (err: Error, ctx: TInput) => Promise<void> | void;\n    /**\n     * An optional completion handler for the node.\n     * This function is called when the node completes (successfully or with error).\n     * If provided, it will be called instead of or in addition to the global onNodeCompleted handler.\n     *\n     * @param event - The node completion event containing status, result, error, context, etc.\n     * @returns A promise that resolves when the handler has completed\n     */\n    onCompleted?: (event: NodeCompletionEvent<TNodeContext>) => Promise<void> | void;\n};\n\n/**\n * Represents a node that can be executed. A node takes a context as input,\n * and returns a (potentially void) value when executed.\n *\n * @template TNodeContext - Type of node context\n * @template TNodeReturn - Type of node return value\n */\nexport class Node<\n    TNodeContext extends Record<string, unknown> & { initial: unknown },\n    TNodeReturn,\n    TPossibleNodeDependencyId extends string = never,\n> {\n    readonly #options: NodeOptions<string, TNodeContext, TNodeReturn, TPossibleNodeDependencyId>;\n\n    #retryPolicy: RetryPolicy = { maxRetries: 0, retryDelayMs: 0 };\n    #status: NodeStatus = \"pending\";\n\n    constructor(options: NodeOptions<string, TNodeContext, TNodeReturn, TPossibleNodeDependencyId>) {\n        if (options.retryPolicy) {\n            this.#validateRetryPolicy(options.retryPolicy);\n            this.#retryPolicy = options.retryPolicy;\n        }\n        this.#options = options;\n    }\n\n    /**\n     * Gets the node's completion handler if one was provided.\n     */\n    get onCompleted(): NodeOptions<string, TNodeContext, TNodeReturn, TPossibleNodeDependencyId>[\"onCompleted\"] {\n        return this.#options.onCompleted;\n    }\n\n    /**\n     * Return whether this node is enabled or not\n     */\n    get isEnabled(): boolean {\n        return this.#options.enabled === undefined || this.#options.enabled;\n    }\n\n    /**\n     * Gets the ID of the node.\n     *\n     * @returns The node ID\n     */\n    get id(): string {\n        return this.#options.id;\n    }\n\n    /**\n     * Executes the node with the given context, retrying if necessary\n     * up to the maximum number of retries specified in the retry policy. Each retry\n     * is separated by the retry delay (in ms) specified in the retry policy.\n     *\n     * @param {TNodeContext} ctx - The node context\n     * @returns {Promise<TNodeReturn>} A promise that resolves with the node result\n     * @throws {Error} If the node execution fails after all retry attempts\n     */\n    async run(ctx: TNodeContext): Promise<TNodeReturn | null> {\n        if (!this.isEnabled) {\n            this.#status = \"skipped\";\n            return null;\n        }\n        const contextToPass = ctx as [TPossibleNodeDependencyId] extends [never]\n            ? TNodeContext\n            : ContextWithDependencies<TNodeContext, TPossibleNodeDependencyId>;\n        // we retry maxRetries times on top of the initial attempt\n        for (let attempt = 0; attempt < this.#retryPolicy.maxRetries + 1; attempt++) {\n            try {\n                this.#status = \"running\";\n                const result = await this.#options.execute(contextToPass);\n                this.#status = \"completed\";\n                return result;\n            } catch (err) {\n                if (attempt === this.#retryPolicy.maxRetries) {\n                    console.error(`Node failed after ${attempt + 1} attempts: ${err}`);\n                    const error = err instanceof Error ? err : new Error(`Non error throw: ${String(err)}`);\n                    try {\n                        if (this.#options.errorHandler) {\n                            await this.#options.errorHandler(error, contextToPass);\n                        } else {\n                            console.error(`Error in node ${this.#options.id}: ${err}`);\n                        }\n                    } catch (error) {\n                        console.error(`Error in node error handler for ${this.#options.id}: ${error}`);\n                    }\n                    this.#status = \"failed\";\n                    throw error;\n                }\n                console.error(`Node failed, retrying (attempt ${attempt + 1}/${this.#retryPolicy.maxRetries}): ${err}`);\n                await setTimeout(this.#retryPolicy.retryDelayMs);\n            }\n        }\n\n        // This line should never be reached due to the for loop condition,\n        // but TypeScript requires a return statement here\n        throw new Error(\"Unexpected end of run method\");\n    }\n\n    /**\n     * Gets the status of the node.\n     *\n     * @returns The current status of the node\n     */\n    get status(): NodeStatus {\n        return this.#status;\n    }\n\n    #validateRetryPolicy(retryPolicy: RetryPolicy) {\n        const { maxRetries, retryDelayMs } = retryPolicy;\n        if (typeof maxRetries !== \"number\" || maxRetries < 0 || !Number.isInteger(maxRetries)) {\n            throw new Error(\"maxRetries must be a non-negative integer\");\n        }\n        if (typeof retryDelayMs !== \"number\" || retryDelayMs < 0) {\n            throw new Error(\"retryDelayMs must be a non-negative number\");\n        }\n    }\n}\n\n/**\n * Defines the retry policy for a node.\n */\ntype RetryPolicy = {\n    /**\n     * The maximum number of retry attempts.\n     */\n    maxRetries: number;\n    /**\n     * The delay in milliseconds between retry attempts.\n     */\n    retryDelayMs: number;\n};\n\n/**\n * Represents the possible states of a node.\n *\n * - pending: Node is pending execution start\n * - running: Node is executing\n * - completed: Node has been executed successfully\n * - failed: Node has failed to execute\n * - skipped: Node was skipped due to being disabled\n */\ntype NodeStatus = \"pending\" | \"running\" | \"completed\" | \"failed\" | \"skipped\";\n","/* --------------------------------------------------------------------------\n  MIT License\n\n  Copyright (c) 2025 Rami Pellumbi\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"), to deal\n  in the Software without restriction, including without limitation the rights\n  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n  copies of the Software, and to permit persons to whom the Software is\n  furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included in all\n  copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n-----------------------------------------------------------------------------*/\n\nexport class NodeError extends Error {\n    public id: string;\n    public error: Error;\n\n    constructor(id: string, error: Error) {\n        super(`Node ${id} failed: ${error.message}`);\n        this.id = id;\n        this.error = error;\n        this.name = \"NodeError\";\n    }\n}\n"],"mappings":"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","names":["error","err"]}